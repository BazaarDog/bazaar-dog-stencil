{"version":3,"sources":["../../../src/client/files/add.js"],"names":["opts","api","add","variadic","args","fileToJsonOpts","pms","progress","onProgressIncrement","createOnProgressIncrement","Array","isArray","map","file","fileToJson","length","concat","addReadableStream","content","objectMode","transform","enc","cb","push","flush","apply","err","res","forEach","addPullStream","deferred","source","abortable","readFnName","through","read","sink","then","resolve","name","catch","abort","onProgress","bytes","incrementBytes","readable","pullStreamToJson","Object","assign","post","data"],"mappings":";;;;;;kBAee,UAAUA,IAAV,EAAgB;AAC7B,MAAMC,MAAM;AACVC,SAAM,YAAM;AACV,UAAMA,MAAM,sBAAYC,QAAZ,CACV,kBACE,YAAa;AAAA,0CAATC,IAAS;AAATA,cAAS;AAAA;;AACX,YAAMC,iBAAiB,EAAEC,KAAKN;;AAE9B;AAFuB,SAAvB,CAGA,IAAII,KAAK,CAAL,KAAWA,KAAK,CAAL,EAAQG,QAAvB,EAAiC;AAC/BF,yBAAeG,mBAAf,GAAqCC,0BAA0BL,KAAK,CAAL,EAAQG,QAAlC,CAArC;AACA,iBAAOH,KAAK,CAAL,EAAQG,QAAf;AACD;;AAEDH,aAAK,CAAL,IAAUM,MAAMC,OAAN,CAAcP,KAAK,CAAL,CAAd,IACNA,KAAK,CAAL,EAAQQ,GAAR,CAAY,UAACC,IAAD;AAAA,iBAAUC,WAAWD,IAAX,EAAiBR,cAAjB,CAAV;AAAA,SAAZ,CADM,GAENS,WAAWV,KAAK,CAAL,CAAX,EAAoBC,cAApB,CAFJ;;AAIA,eAAOD,IAAP;AACD,OAfH,EAgBE,wBAAO,gBAAP,EAAyBJ,IAAzB,CAhBF,CADU,CAAZ;;AAqBA,aAAO,YAAa;AAAA,2CAATI,IAAS;AAATA,cAAS;AAAA;;AAClB;AACA;AACA;AACA,YAAIA,KAAKW,MAAL,KAAgB,CAAhB,IAAqB,4BAASX,KAAK,CAAL,CAAT,CAAzB,EAA4C;AAC1CA,iBAAOA,KAAKY,MAAL,CAAY,IAAZ,CAAP;AACD;;AAED,eAAOd,wCAAOE,IAAP,EAAP;AACD,OATD;AAUD,KAhCI,EADK;AAkCV;AACAa,qBAnCU,+BAmCkB;AAAA,yCAANb,IAAM;AAANA,YAAM;AAAA;;AAC1B,UAAMc,UAAU,EAAhB;AACA,aAAO,sBAAc;AACnBC,oBAAY,IADO;AAEnBC,iBAFmB,qBAERP,IAFQ,EAEFQ,GAFE,EAEGC,EAFH,EAEO;AACxBJ,kBAAQK,IAAR,CAAaV,IAAb;AACAS;AACD,SALkB;AAMnBE,aANmB,iBAMZF,EANY,EAMR;AAAA;;AACTrB,cAAIC,GAAJ,CAAQuB,KAAR,CAAcxB,GAAd,EAAmB,CAACiB,OAAD,EAAUF,MAAV,CAAiBZ,IAAjB,EAAuB,UAACsB,GAAD,EAAMC,GAAN,EAAc;AACtD,gBAAID,GAAJ,EAAS,OAAOJ,GAAGI,GAAH,CAAP;AACTC,gBAAIC,OAAJ,CAAY,UAACf,IAAD;AAAA,qBAAU,MAAKU,IAAL,CAAUV,IAAV,CAAV;AAAA,aAAZ;AACAS;AACD,WAJkB,CAAnB;AAKD;AAZkB,OAAd,CAAP;AAcD,KAnDS;;AAoDVO,mBAAgB,YAAM;AACpB,UAAMA,gBAAgB,wBAAO,0BAAP,EAAmC7B,IAAnC,CAAtB;;AAEA,aAAO,YAAa;AAAA,2CAATI,IAAS;AAATA,cAAS;AAAA;;AAClB,YAAM0B,WAAW,oBAAMC,MAAN,EAAjB;AACA,YAAMC,YAAY,8BAAlB;AACA,YAAM3B,iBAAiB,EAAEC,KAAKN;;AAE9B;AAFuB,SAAvB,CAGA,IAAII,KAAK,CAAL,KAAWA,KAAK,CAAL,EAAQG,QAAvB,EAAiC;AAC/BF,yBAAeG,mBAAf,GAAqCC,0BAA0BL,KAAK,CAAL,EAAQG,QAAlC,CAArC;AACA,iBAAOH,KAAK,CAAL,EAAQG,QAAf;AACD;;AAED,YAAM0B,aAAa,wBAAnB;;AAEA;AACA;AACA;AACA;AACA,YAAMC,UAAU,SAAVA,OAAU,CAAUC,IAAV,EAAgB;AAC9B,sCAAIC,IAAJ,CAASH,UAAT,EAAqBjC,IAArB,EAA2BmC,IAA3B;AACA,iBAAOL,QAAP;AACD,SAHD;;AAKA;AACA;AACAD,wCAAc,8BAAeI,UAAf,CAAd,SAA6C7B,IAA7C,GACGiC,IADH,CACQ,UAACV,GAAD;AAAA,iBAASG,SAASQ,OAAT,CAAiB,4BAAIP,MAAJ,CAAWJ,IAAIY,IAAf,EAAqBvC,IAArB,CAAjB,CAAT;AAAA,SADR,EAEGwC,KAFH,CAES,UAACd,GAAD;AAAA,iBAASM,UAAUS,KAAV,CAAgBf,GAAhB,CAAT;AAAA,SAFT;;AAIA,eAAO,0BACL,qBAAKd,GAAL,CAAS,UAACC,IAAD;AAAA,iBAAUC,WAAWD,IAAX,EAAiBR,cAAjB,CAAV;AAAA,SAAT,CADK,EAEL6B,OAFK,EAGLF,SAHK,CAAP;AAKD,OAjCD;AAkCD,KArCc;AApDL,GAAZ;;AA4FA,SAAO/B,GAAP;AACD,C;;AA7GD;;AACA;;;;AACA;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;AACA;;;;AACA;;AACA;;;;AACA;;;;AACA;;AACA;;;;;;AAkGA,SAASQ,yBAAT,CAAoCiC,UAApC,EAAgD;AAC9C,MAAIC,QAAQ,CAAZ;AACA,SAAO,UAACC,cAAD,EAAoB;AACzBD,aAASC,cAAT;AACAF,eAAWC,KAAX;AACA,WAAOA,KAAP;AACD,GAJD;AAKD;;AAED,SAAS7B,UAAT,CAAqBD,IAArB,EAA2Bb,IAA3B,EAAiC;AAC/BA,SAAOA,QAAQ,EAAf;;AAEA,MAAI,sBAASa,IAAT,CAAJ,EAAoB;AAAE;AACpB,QAAIb,KAAKQ,mBAAT,EAA8BR,KAAKQ,mBAAL,CAAyBK,KAAKE,MAA9B;AAC9B,WAAO,0BAAaF,IAAb,CAAP;AACD,GAHD,MAGO,IAAI,mBAASgC,QAAT,CAAkBhC,IAAlB,CAAJ,EAA6B;AAAE;AACpC,WAAOiC,iBAAiB,6BAAOf,MAAP,CAAclB,IAAd,CAAjB,EAAsCb,IAAtC,CAAP;AACD,GAFM,MAEA,IAAI,4BAASa,IAAT,CAAJ,EAAoB;AAAE;AAC3B,WAAOiC,iBAAiBjC,IAAjB,EAAuBb,IAAvB,CAAP;AACD,GAFM,MAEA,IAAIa,QAAQA,KAAKK,OAAjB,EAA0B;AAAE;AACjC,WAAO6B,OAAOC,MAAP,CAAc,EAAd,EAAkBnC,IAAlB,EAAwB,EAAEK,SAASJ,WAAWD,KAAKK,OAAhB,EAAyBlB,IAAzB,CAAX,EAAxB,CAAP;AACD;;AAED,SAAOa,IAAP,CAd+B,CAcnB;AACb;;AAED,IAAMiC,mBAAmB,SAAnBA,gBAAmB,CAACf,MAAD,EAAS/B,IAAT,EAAkB;AACzCA,SAAOA,QAAQ,EAAf;AACA,MAAMiC,aAAa,wBAAnB;;AAEA,4BACEF,MADF,EAEE,4BAAIK,IAAJ,CAASH,UAAT,EAAqBc,OAAOC,MAAP,CAAc,EAAd,EAAkBhD,KAAKM,GAAvB,EAA4B;AAC/C2C,QAD+C,gBACzCtB,GADyC,EACpC;AACT,UAAI,sBAASA,IAAIuB,IAAb,CAAJ,EAAwB;AACtB,YAAIlD,KAAKQ,mBAAT,EAA8BR,KAAKQ,mBAAL,CAAyBmB,IAAIuB,IAAJ,CAASnC,MAAlC;AAC9BY,YAAIuB,IAAJ,GAAW,0BAAavB,IAAIuB,IAAjB,CAAX;AACD;;AAED,aAAOvB,GAAP;AACD;AAR8C,GAA5B,CAArB,CAFF;;AAcA,SAAO,8BAAeM,UAAf,CAAP;AACD,CAnBD","file":"add.js","sourcesContent":["import { caller } from 'postmsg-rpc'\nimport callbackify from 'callbackify'\nimport { Transform } from 'stream'\nimport pull from 'pull-stream'\nimport PMS from 'pull-postmsg-stream'\nimport toPull from 'stream-to-pull-stream'\nimport isStream from 'is-stream'\nimport { isSource } from 'is-pull-stream'\nimport shortid from 'shortid'\nimport { pre } from 'prepost'\nimport defer from 'pull-defer'\nimport Abortable from 'pull-abortable'\nimport { isBuffer, bufferToJson } from '../../serialization/buffer'\nimport { functionToJson } from '../../serialization/function'\n\nexport default function (opts) {\n  const api = {\n    add: (() => {\n      const add = callbackify.variadic(\n        pre(\n          (...args) => {\n            const fileToJsonOpts = { pms: opts }\n\n            // FIXME: implement progress properly\n            if (args[1] && args[1].progress) {\n              fileToJsonOpts.onProgressIncrement = createOnProgressIncrement(args[1].progress)\n              delete args[1].progress\n            }\n\n            args[0] = Array.isArray(args[0])\n              ? args[0].map((file) => fileToJson(file, fileToJsonOpts))\n              : fileToJson(args[0], fileToJsonOpts)\n\n            return args\n          },\n          caller('ipfs.files.add', opts)\n        )\n      )\n\n      return (...args) => {\n        // Pull streams are just functions and so callbackify.variadic thinks\n        // the stream is a callback function! Instead explicitly pass null for\n        // the options arg.\n        if (args.length === 1 && isSource(args[0])) {\n          args = args.concat(null)\n        }\n\n        return add(...args)\n      }\n    })(),\n    // FIXME: implement add readable stream properly\n    addReadableStream (...args) {\n      const content = []\n      return new Transform({\n        objectMode: true,\n        transform (file, enc, cb) {\n          content.push(file)\n          cb()\n        },\n        flush (cb) {\n          api.add.apply(api, [content].concat(args, (err, res) => {\n            if (err) return cb(err)\n            res.forEach((file) => this.push(file))\n            cb()\n          }))\n        }\n      })\n    },\n    addPullStream: (() => {\n      const addPullStream = caller('ipfs.files.addPullStream', opts)\n\n      return (...args) => {\n        const deferred = defer.source()\n        const abortable = Abortable()\n        const fileToJsonOpts = { pms: opts }\n\n        // FIXME: implement progress properly\n        if (args[0] && args[0].progress) {\n          fileToJsonOpts.onProgressIncrement = createOnProgressIncrement(args[0].progress)\n          delete args[0].progress\n        }\n\n        const readFnName = shortid()\n\n        // Create the through stream what will connect the client to the\n        // server, our source is deferred, until the server responds to tell\n        // us the name of the read function we can use to pull added file\n        // info from.\n        const through = function (read) {\n          PMS.sink(readFnName, opts)(read)\n          return deferred\n        }\n\n        // Call addPullStream on the server, sending the name of the read\n        // function it can use to pull files to add from.\n        addPullStream(functionToJson(readFnName), ...args)\n          .then((res) => deferred.resolve(PMS.source(res.name, opts)))\n          .catch((err) => abortable.abort(err))\n\n        return pull(\n          pull.map((file) => fileToJson(file, fileToJsonOpts)),\n          through,\n          abortable\n        )\n      }\n    })()\n  }\n\n  return api\n}\n\nfunction createOnProgressIncrement (onProgress) {\n  let bytes = 0\n  return (incrementBytes) => {\n    bytes += incrementBytes\n    onProgress(bytes)\n    return bytes\n  }\n}\n\nfunction fileToJson (file, opts) {\n  opts = opts || {}\n\n  if (isBuffer(file)) { // Buffer\n    if (opts.onProgressIncrement) opts.onProgressIncrement(file.length)\n    return bufferToJson(file)\n  } else if (isStream.readable(file)) { // Node stream\n    return pullStreamToJson(toPull.source(file), opts)\n  } else if (isSource(file)) { // Pull stream\n    return pullStreamToJson(file, opts)\n  } else if (file && file.content) { // Object { path?, content }\n    return Object.assign({}, file, { content: fileToJson(file.content, opts) })\n  }\n\n  return file // Object { path } maybe, but could be anything\n}\n\nconst pullStreamToJson = (source, opts) => {\n  opts = opts || {}\n  const readFnName = shortid()\n\n  pull(\n    source,\n    PMS.sink(readFnName, Object.assign({}, opts.pms, {\n      post (res) {\n        if (isBuffer(res.data)) {\n          if (opts.onProgressIncrement) opts.onProgressIncrement(res.data.length)\n          res.data = bufferToJson(res.data)\n        }\n\n        return res\n      }\n    }))\n  )\n\n  return functionToJson(readFnName)\n}\n"]}