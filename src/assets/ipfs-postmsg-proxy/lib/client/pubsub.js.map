{"version":3,"sources":["../../src/client/pubsub.js"],"names":["opts","subs","api","publish","variadic","subscribe","topic","options","handler","cb","sub","stub","args","handlerIndex","length","fnName","rpc","exposedFn","data","seqno","process","nextTick","Promise","resolve","push","catch","err","close","splice","indexOf","then","res","unsubscribe","find","s","peers","ls","setMaxListeners"],"mappings":"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","file":"pubsub.js","sourcesContent":["import { caller, expose } from 'postmsg-rpc'\nimport callbackify from 'callbackify'\nimport shortid from 'shortid'\nimport { pre } from 'prepost'\nimport { functionToJson } from '../serialization/function'\nimport { isBufferJson, bufferFromJson, preBufferToJson } from '../serialization/buffer'\n\nexport default function (opts) {\n  const subs = [\n  /*\n    {\n      topic,      // name of the topic subscribed to\n      handler,    // the handler provided by the subscriber - rpc.exposedFn calls this function\n      rpc: {      // details of the exposed RPC function created to receive updates\n        fnName,   // the RPC function name\n        exposedFn // the exposed RPC function created by postmsg-rpc\n      }\n    }\n  */\n  ]\n\n  const api = {\n    publish: callbackify.variadic(\n      pre(\n        preBufferToJson(1),\n        caller('ipfs.pubsub.publish', opts)\n      )\n    ),\n    subscribe: function (topic, options, handler, cb) {\n      let sub\n\n      if (typeof options === 'function') {\n        cb = handler\n        handler = options\n        options = {}\n      }\n\n      const stub = pre(\n        (...args) => {\n          const handlerIndex = args.length === 3 ? 2 : 1\n          const fnName = `ipfs.pubsub.subscribe.handler.${shortid()}`\n\n          sub = {\n            topic,\n            handler,\n            rpc: {\n              fnName,\n              exposedFn: expose(fnName, pre(\n                (...args) => {\n                  if (args[0]) {\n                    if (isBufferJson(args[0].data)) {\n                      args[0].data = bufferFromJson(args[0].data)\n                    }\n\n                    if (isBufferJson(args[0].seqno)) {\n                      args[0].seqno = bufferFromJson(args[0].seqno)\n                    }\n                  }\n\n                  return args\n                },\n                (...args) => {\n                  process.nextTick(() => handler(...args))\n                  return Promise.resolve()\n                }\n              ), opts)\n            }\n          }\n\n          subs.push(sub)\n\n          args[handlerIndex] = functionToJson(fnName)\n\n          return args\n        },\n        // If error, then remove subscription handler\n        (...args) => {\n          return caller('ipfs.pubsub.subscribe', opts)(...args)\n            .catch((err) => {\n              sub.rpc.exposedFn.close()\n              subs.splice(subs.indexOf(sub), 1)\n              throw err\n            })\n        }\n      )\n\n      if (cb) {\n        stub(topic, options, handler)\n          .then((res) => process.nextTick(() => cb(null, res)))\n          .catch((err) => process.nextTick(() => cb(err)))\n      } else {\n        return stub(topic, options, handler)\n      }\n    },\n    unsubscribe: pre(\n      (...args) => {\n        const topic = args[0]\n        const sub = subs.find((s) => s.topic === topic && s.handler === args[1])\n\n        if (sub) {\n          args[1] = functionToJson(sub.rpc.fnName)\n          sub.rpc.exposedFn.close()\n          subs.splice(subs.indexOf(sub), 1)\n        }\n\n        return args\n      },\n      caller('ipfs.pubsub.unsubscribe', opts)\n    ),\n    peers: callbackify.variadic(caller('ipfs.pubsub.peers', opts)),\n    ls: callbackify.variadic(caller('ipfs.pubsub.ls', opts)),\n    // interface-ipfs-core tests use this function\n    // noop since we're not an EventEmitter\n    setMaxListeners: () => api\n  }\n\n  return api\n}\n"]}