{"version":3,"sources":["../../src/server/pubsub.js"],"names":["getIpfs","opts","subs","api","publish","pre","pubsub","subscribe","args","sub","topic","handlerIndex","length","stubFn","Object","assign","data","seqno","name","rpc","fnName","push","catch","err","splice","indexOf","unsubscribe","find","s","Promise","resolve","peers","ls","setTimeout","close","forEach"],"mappings":"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","file":"pubsub.js","sourcesContent":["import { expose, caller } from 'postmsg-rpc'\nimport { pre } from 'prepost'\nimport { isFunctionJson } from '../serialization/function'\nimport { isBuffer, bufferToJson, preBufferFromJson } from '../serialization/buffer'\n\nexport default function (getIpfs, opts) {\n  const subs = [\n  /*\n    {\n      topic,    // name of the topic subscribed to\n      rpc: {    // details of the RPC stub created to send updates\n        fnName, // the RPC function name the stub calls\n        stubFn  // the RPC stub function created by postmsg-rpc\n      }\n    }\n  */\n  ]\n\n  const api = {\n    publish: expose('ipfs.pubsub.publish', pre(\n      preBufferFromJson(1),\n      opts.pre('pubsub.publish'),\n      (...args) => getIpfs().pubsub.publish(...args)\n    ), opts),\n    subscribe: expose('ipfs.pubsub.subscribe', function (...args) {\n      let sub\n\n      return pre(\n        (...args) => {\n          const topic = args[0]\n          const handlerIndex = args.length === 3 ? 2 : 1\n\n          if (isFunctionJson(args[handlerIndex])) {\n            const stubFn = pre(\n              (...args) => {\n                if (args[0]) {\n                  args[0] = Object.assign({}, args[0])\n\n                  if (isBuffer(args[0].data)) {\n                    args[0].data = bufferToJson(args[0].data)\n                  }\n\n                  if (isBuffer(args[0].seqno)) {\n                    args[0].seqno = bufferToJson(args[0].seqno)\n                  }\n                }\n\n                return args\n              },\n              caller(args[handlerIndex].name, opts)\n            )\n\n            sub = {\n              topic,\n              rpc: {\n                fnName: args[handlerIndex].name,\n                stubFn\n              }\n            }\n\n            subs.push(sub)\n\n            args[handlerIndex] = stubFn\n          }\n\n          return args\n        },\n        opts.pre('pubsub.subscribe'),\n        (...args) => {\n          return getIpfs().pubsub.subscribe(...args)\n            .catch((err) => {\n              subs.splice(subs.indexOf(sub), 1)\n              throw err\n            })\n        }\n      )(...args)\n    }, opts),\n    unsubscribe: expose('ipfs.pubsub.unsubscribe', pre(\n      (...args) => {\n        const topic = args[0]\n\n        if (isFunctionJson(args[1])) {\n          const sub = subs.find((s) => s.topic === topic && s.rpc.fnName === args[1].name)\n\n          if (sub) {\n            args[1] = sub.rpc.stubFn\n            subs.splice(subs.indexOf(sub), 1)\n          } else {\n            // Well, we don't have a reference to it, so the ipfs node won't\n            // either. We shouldn't error either because ipfs won't.\n            args[1] = () => {}\n          }\n        }\n\n        return args\n      },\n      opts.pre('pubsub.unsubscribe'),\n      (...args) => new Promise((resolve) => {\n        getIpfs().pubsub.unsubscribe(...args)\n        resolve()\n      })\n    ), opts),\n    peers: expose('ipfs.pubsub.peers', pre(\n      opts.pre('pubsub.peers'),\n      (...args) => getIpfs().pubsub.peers(...args)\n    ), opts),\n    ls: expose('ipfs.pubsub.ls', pre(\n      // FIXME: The interface-ipfs-core tests call ls straight after unsubscribe.\n      // Unsubscribe in js-ipfs is synchronous but it HAS to be async in the\n      // proxy because window.postMessage is asynchronous.\n      (...args) => new Promise((resolve) => setTimeout(() => resolve(args))),\n      opts.pre('pubsub.ls'),\n      (...args) => getIpfs().pubsub.ls(...args)\n    ), opts)\n  }\n\n  // Clean up any subscriptions on close\n  api.subscribe.close = pre(\n    (...args) => {\n      subs.forEach((sub) => getIpfs().pubsub.unsubscribe(sub.topic, sub.rpc.stubFn))\n      return args\n    },\n    api.subscribe.close\n  )\n\n  return api\n}\n"]}